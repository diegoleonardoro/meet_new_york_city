
    /*

    function animatedForm() {

        const arrows = document.querySelectorAll(".fa-arrow-down");
        arrows.forEach(arrow => {

            arrow.addEventListener("click", () => {

                const input = arrow.previousElementSibling;
                const parent = arrow.parentElement;
                var inputValue = input.value;

                if (input.name === "text" && validateUser(input)) {
                    const nextForm = parent.nextElementSibling; // represents the address
                    const nextForm2 = nextForm.nextElementSibling; // represents the section
                    passName(inputValue, parent, nextForm, 1, -400  );

                } else if (input.name === "address" && validateAddress(input)) {
                    const nextForm = parent.nextElementSibling; // represents the section.
                    passAddress(parent, -400, nextForm);
                }
            })
        })
    }


    function validateUser(user) {
        if (user.value.length < 2) {
            console.log("Not enough characters");
            error("rgb(189,87,87)");
        } else {
            error("white");
            return true;
        }
    }
    function validateAddress(address) {
        if (address.value.length > 3) {

            error("white");
            return true;
        } else {
            error("rgb(189,87,87)");
        }
    }
    function error(color) {
        document.body.style.backgroundColor = color;
    }

    animatedForm()


    function passName(inputValue, parent, nextForm, nextFormOpacity, transformValue) {

        var parentWidth = inputValue.length * 10
        parent.style.display = "none";
        nextForm.style.opacity = nextFormOpacity;
        var addressSection = document.querySelector(".field-address");
        addressSection.style.display = "flex";

    }

    function passAddress(parent, transformValue, nextForm) {

        parent.style.display = "none";
        var firstSection = document.querySelector('.firstSection');
        var firstQuestionHeading = document.getElementById("firstQuestionHeading");
        firstQuestionHeading.style.display = "inline";

        for (let i = 0; i < firstSection.children.length; i++) {
            let div = firstSection.children[i];
            let label = div.children[0].className += " show";
        }
    }
    */



// -------------------------------------------------------- //
    // ------- THE FOLLOWING HANDLES THE FIRST SECTION -------- //

    function handelClickedSection(i) {

        dynamicQuestionnaireLabelsArray[i].className += " " + "checked"; // "label"
        // dynamicQuestionnaireLabelsArray[i].className += " " + "show" + " " + "checked"; // "label"

        var labelParent = dynamicQuestionnaireLabelsArray[i].parentElement; // "div" 
        var sectionElement = labelParent.parentElement; //  "section"
        var nameField = document.getElementsByClassName("field-name");
        var nameFieldScreenCoords = nameField[0].getBoundingClientRect();


        if (sectionElement.className === "firstSection") {
            sectionElement.style.top = nameFieldScreenCoords.bottom - 15 + "px";
            sectionElement.style.left = nameFieldScreenCoords.left + "px";
        }


        //Section -> div -> label

    }


    // --------- THE FOLLOWING HANDLES THE 2ND, 3RD AND 4RD SECTIONS ----------- //

    function handleOtherClickedSections(i) {

        dynamicQuestionnaireLabelsArray[i].className += " " + "checked";
        var labelParent = dynamicQuestionnaireLabelsArray[i].parentElement; // "div" 
        var sectionElement = labelParent.parentElement; //  "section" element of the clicked label
        var h3 = sectionElement.previousElementSibling;
        var previousSectionCoords = h3.previousElementSibling.getBoundingClientRect();

        //.getBoundingClientRect();

        // PREVIOUS ELEMENT => H3 => SECTION => DIV => LABEL

        sectionElement.style.top = previousSectionCoords.bottom + -40 + "px";
        sectionElement.style.left = previousSectionCoords.left + "px";

    }




const dynamicQuestionnaireLabels = document.querySelectorAll(".filterDiv");
const dynamicQuestionnaireLabelsArray = Array.from(dynamicQuestionnaireLabels); /* 1. */




        /*
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        d3.json("nyc-streets.json", function (error, data) {
 
            var streets = data
            //------------------- SELECT ONLY THE STREETS OF THE BRONX  ----------------------//
            var bx = function () { // <--- We select only the streets that belong to The Bronx. 
                var bx_ = []
                for (var i = 0; i < streets.features.length; i++) {
                    if (streets.features[i].properties["COUNTYFP"] === "005") {
                        bx_.push(streets.features[i])
                    }
                }
                return bx_
            }
            var bx__ = bx()
 
            //--------------------------------------------------------------------------------//
            //-----------------------SCALE AND TRANSLATE OF BRONX STREETS--------------------//
            var b, s, t;
            projection.scale(1).translate([0, 0]);
            var b = path.bounds(streets); // bounds represent a two dimensional array : [[left, bottom], [right, top]],
            var s = 79223.27711444911;
            var t = [102889.63407417801, 62171.50097311522];
            projection.scale(s).translate(t);
 
            //--------------------- ADD THE STREETS TO THIS NEW "G" TAG ---------------------//
 
            streetMap = map.append("g").attr("class", "boundary2"); // We append another "g" element to the "g"
            nycStreets = streetMap.selectAll("path").data(streets.features)
            nycStreets.enter()
                .append("path")
                .attr("d", path)
                .attr("stroke-width", "0.1")
                .attr("stroke-opacity", "0.3")
                .style("fill-opacity", 0)
                .style("stroke", "black")
            nycStreets.attr("fill", "#eee");
            nycStreets.exit().remove()
 
            //--------------------------------------------------------------------------------//
 
 
            // ---- ADD EVENT LISTENER TO THE BUTTON THAT SUBMITS THE ADDRESS ---- //
 
 
            const addressArrow = document.getElementById("addressArrow");
            const reasonArrow = document.getElementById("reasonArrow");
            const nameArrow = document.getElementById("nameArrow");
            const imageArrow = document.getElementById("imageArrow");
 
 
            // --- ADD AN EVENT LISTENER TO THE ADDRESS ARROW --- //
            // THIS EVENT LISTENER WILL PINPOINT WHERE THE ADDRESS IS LOCATED IN THE MAP
 
            var placeCoords = [];
 
            addressArrow.addEventListener("click", () => {
                const address = addressArrow.previousElementSibling.value;
                getPlaceInfo(address, (error, response) => {
 
                    var coords = [response.items[0].position]
 
                    var divLeftStyle = projection([coords[0].lng.toString(), coords[0].lat.toString()])[0]
                    var divTopStyle = projection([coords[0].lng.toString(), coords[0].lat.toString()])[1]
 
                    placeCoords.push(divLeftStyle, divTopStyle);
 
                    var circle = map.append("circle")
                        .attr("cx", divLeftStyle)
                        .attr("cy", divTopStyle)
                        .attr("r", 6)
                        .attr("fill", "blue");
 
                    //  console.log("1", projection([coords[0].lng.toString(), coords[0].lat.toString()])[0])
                    //  console.log("2", projection([coords[0].lng.toString(), coords[0].lat.toString()])[1])
 
                })
            })

    




      /*
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        //------------------- READING THE STREETS TO BE DISPLAYED ON THE MAP ----------------------//
        d3.json("nyc-streets.json", function (error, data) {
 
            var streets = data
            //------------------- SELECT ONLY THE STREETS OF THE BRONX  ----------------------//
            var bx = function () { // <--- We select only the streets that belong to The Bronx. 
                var bx_ = []
                for (var i = 0; i < streets.features.length; i++) {
                    if (streets.features[i].properties["COUNTYFP"] === "005") {
                        bx_.push(streets.features[i])
                    }
                }
                return bx_
            }
            var bx__ = bx()
 
            //--------------------------------------------------------------------------------//
            //-----------------------SCALE AND TRANSLATE OF BRONX STREETS--------------------//
            var b, s, t;
            projection.scale(1).translate([0, 0]);
            var b = path.bounds(streets); // bounds represent a two dimensional array : [[left, bottom], [right, top]],
            var s = 79223.27711444911;
            var t = [102889.63407417801, 62171.50097311522];
            projection.scale(s).translate(t);
 
            //--------------------- ADD THE STREETS TO THIS NEW "G" TAG ---------------------//
 
            streetMap = map.append("g").attr("class", "boundary2"); // We append another "g" element to the "g"
            nycStreets = streetMap.selectAll("path").data(streets.features)
            nycStreets.enter()
                .append("path")
                .attr("d", path)
                .attr("stroke-width", "0.1")
                .attr("stroke-opacity", "0.3")
                .style("fill-opacity", 0)
                .style("stroke", "black")
            nycStreets.attr("fill", "#eee");
            nycStreets.exit().remove()
 
            //--------------------------------------------------------------------------------//
 
 
            // ---- ADD EVENT LISTENER TO THE BUTTON THAT SUBMITS THE ADDRESS ---- //
 
 
            const addressArrow = document.getElementById("addressArrow");
            const reasonArrow = document.getElementById("reasonArrow");
            const nameArrow = document.getElementById("nameArrow");
            const imageArrow = document.getElementById("imageArrow");
 
 
            // --- ADD AN EVENT LISTENER TO THE ADDRESS ARROW --- //
            // THIS EVENT LISTENER WILL PINPOINT WHERE THE ADDRESS IS LOCATED IN THE MAP
 
            var placeCoords = [];
 
            addressArrow.addEventListener("click", () => {
                const address = addressArrow.previousElementSibling.value;
                getPlaceInfo(address, (error, response) => {
 
                    var coords = [response.items[0].position]
 
                    var divLeftStyle = projection([coords[0].lng.toString(), coords[0].lat.toString()])[0]
                    var divTopStyle = projection([coords[0].lng.toString(), coords[0].lat.toString()])[1]
 
                    placeCoords.push(divLeftStyle, divTopStyle);
 
                    var circle = map.append("circle")
                        .attr("cx", divLeftStyle)
                        .attr("cy", divTopStyle)
                        .attr("r", 6)
                        .attr("fill", "blue");
 
                    //  console.log("1", projection([coords[0].lng.toString(), coords[0].lat.toString()])[0])
                    //  console.log("2", projection([coords[0].lng.toString(), coords[0].lat.toString()])[1])
 
                })
            })
 



 /*
            // ==================================================== //
            // ==================================================== //
            // = CREATE A FUNCTION THAT WILL TYPE THE CHARACTERS == // 
            // ==================================================== //
            // ==================================================== //
 
 
 
 
            function createTooltip(heigh, width, currentLabel) { //This function needs to be called after the circle is shown on the map. That is why I added "setTimeout" before calling it. 
 
                return new Promise((resolve, reject) => {
 
                    setTimeout(function () {
                        var rect = map.append("rect")
                            //.attr("x", 682.3483095269039)
                            //.attr("y", 248.13190205079445)
                            .attr("x", placeCoords[0])
                            .attr("y", placeCoords[1])
                            .attr("height", heigh)
                            .attr("width", width)
                            .attr("id", "placeTooltip")
                            .style("fill", "black")
 
                        //  console.log(placeCoords[0]) // 682.3483095269039
                        //  console.log(placeCoords[1]) // 248.13190205079445
 
 
                        let typeOfBuilding = dynamicQuestionnaireLabelsArray[currentLabel].textContent.trim()
                        let placeTooltip = document.getElementById("placeTooltip"); //<-----
                        let placeTooltipCoods = placeTooltip.getBoundingClientRect()//<-----
                        let typedTextParagraph = document.getElementById("typedText");
                        let toolTipText = "This is a" + " " + typeOfBuilding + " " + "building";
                        let topCoord = placeTooltipCoods.top;//<-----
                        let leftCoord = placeTooltipCoods.left;//<-----
                        let paragraphText = "";
                        let counter = 0;
 
                        resolve([typedTextParagraph, toolTipText, topCoord, leftCoord, paragraphText, counter])
 
                    }, 1500)
 
                })
 
            }
 
 
 
 
            /// ========================================== ///
 
 
            const typeFirstText = function (resolvedValue) {
 
                return new Promise((resolve, reject) => {
 
                    let txtElmntParagraph = resolvedValue[0];
                    let textString = resolvedValue[1];
                    let topPosition = resolvedValue[2];
                    let leftPosition = resolvedValue[3];
                    let paragraphText = resolvedValue[4];
                    let counter = resolvedValue[5];
 
                    function typeDelay(i) {
 
                        setTimeout(() => {
                            paragraphText = paragraphText + textString.charAt(i);
                            txtElmntParagraph.innerHTML = paragraphText;
                            txtElmntParagraph.style.top = topPosition + 10 + "px";
                            txtElmntParagraph.style.left = leftPosition + 10 + "px";
                            txtElmntParagraph.style.color = "white";
                            //counter++
                            if (paragraphText === textString) {
                                resolve(paragraphText)
                            }
                        }, 50 * i);
                    }
 
                    for (var i = 0; i < textString.length; i++) {
                        typeDelay(i);
                    }
 
 
                })
            }
 
            /// ========================================== ///
 
            /// ========================================== ///
 
 
            function typeText(nextSectionElement, previousLabelElement) { // previousLabelElement is used 
 
                return new Promise((resolve, reject) => {
 
                    for (var i = 0; i < dynamicQuestionnaireLabelsArray.length; i++) {
 
                        let currentLabel = i;
 
                        var divElement = dynamicQuestionnaireLabelsArray[currentLabel].parentElement
                        var sectionElement = divElement.parentElement;
 
                        if (nextSectionElement.className === sectionElement.className) {
 
                            dynamicQuestionnaireLabelsArray[i].children[0].addEventListener("click", function type() {// 9.  Add a click event to the input inside the LABELS that have DISPLAY: INLINE. 
 
                                //const imageDiv = document.getElementById("divImage"); // Just delete this line in case you wanna go back. <<<<<<<<=========---------------------------------------------------------------------------------------------------------------
                                //imageDiv.addEventListener("click", function type() {  // Just delete this line in case you wanna go back.  <<<<<<<<=========---------------------------------------------------------------------------------------------------------------
 
                                let labelText = dynamicQuestionnaireLabelsArray[currentLabel].textContent.replace(/[\n\r]+|[\s]{2,}/g, ' ').trim() // 10. Get the text inside the label.
 
                                let typedTextParagraph = document.getElementById("typedText"); // 11. Get the text that we alredy typed and add it an " "
 
                                typedTextParagraph.innerHTML = typedTextParagraph.innerHTML + " "
 
                                let brokenText = typedTextParagraph.innerHTML.split("<br>");
 
                                let lastLineText = brokenText[brokenText.length - 1]; // 12. Get the last line of the text that was previously typed- 
 
 
                                function typeDelay(i, u, newText) {
 
                                    setTimeout(() => {
 
                                        newText += labelText.charAt(u); // 15. Start populating newText.
                                        typedTextParagraph.innerHTML = typedTextParagraph.innerHTML + labelText.charAt(u); // 16. Inject characters to typedTextParagraph 
 
                                        u++;
                                        i++;
 
                                        if (newText === labelText) {
 
                                            resolve([currentLabel, previousLabelElement]);
 
                                        } else {
                                            typeChars(i, u, newText); // 16. call typeChars again. Adding one to i and u. 
                                        }
                                    }, 50);
                                }
 
                                function typeChars(i, u, newText) {
 
                                    if (i < 52) { // 14.  if the length of last line is smaller that 52
                                        typeDelay(i, u, newText); //  length of last line / 0 / " "
                                    } else if (i >= 52 && typedTextParagraph.innerHTML.charAt(typedTextParagraph.innerHTML.length - 1) != " ") {
                                        typeDelay(i, u, newText);
                                    } else if (i >= 52 && typedTextParagraph.innerHTML.charAt(typedTextParagraph.innerHTML.length - 1) === " ") {
                                        typedTextParagraph.innerHTML += "<br>";
 
                                        i = 0;
                                        typeChars(i, u, newText);
                                    }
                                }
 
                                let newText = "";
 
                                typeChars(lastLineText.length, 0, newText); // 13. Call typeChars(). Pass: length of last line / 0 / empty string. 
 
                            })//
                        }
                    }
                })
            }



            /*
 
 
            /// ========================================== ///
            /// ===========PROMISE CHAIN SECTION========== ///
            /// ========================================== ///
            /// ========================================== ///
            /// ===========PROMISE CHAIN SECTION========== ///
            /// ========================================== ///
            /// ========================================== ///
            /// ===========PROMISE CHAIN SECTION========== ///
            /// ========================================== ///
 
            
 
            for (var i = 0; i < dynamicQuestionnaireLabelsArray.length; i++) {
 
                var divLabel = dynamicQuestionnaireLabelsArray[i].parentElement;
 
                if (divLabel.parentElement.className === "firstSection") {
 
                    let currentLabel = i
 
                    dynamicQuestionnaireLabelsArray[currentLabel].children[0].addEventListener("click", function () {
 
                        createTooltip(400, 500, currentLabel)
 
                            .then((resolvedValue) => {
 
                                return typeFirstText(resolvedValue)
 
                            }).then((resValue) => {
 
                                var labelParentElememtn = dynamicQuestionnaireLabelsArray[currentLabel].parentElement.className.split(" ")
                                var labelParentElememtnFilterValue = labelParentElememtn[1];
 
                                // --------------------------------------------------------------------------------------------- //
                                var parentDiv = dynamicQuestionnaireLabelsArray[currentLabel].parentElement;
 
                                // --------------------------------------------------------------------------------------------- //
 
 
                                var section = parentDiv.parentElement;
                                var nextSectionElement = section.nextElementSibling;
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var firstQuestionHeading = document.getElementById("firstQuestionHeading");
                                firstQuestionHeading.style.display = "none";
                                // --------------------------------------------------------------------------------------------- //
 
                                // --------------------------------------------------------------------------------------------- //
                                // handelClickedSection(currentLabel);
                                filterSelection(labelParentElememtnFilterValue);
                                // --------------------------------------------------------------------------------------------- //
 
                                // --------------------------------------------------------------------------------------------- //
                                var secondQuestionHeading = document.getElementById(labelParentElememtnFilterValue);
                                secondQuestionHeading.style.display = "inline";
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // SECOND SECTION TYPING //
 
                                return typeText(nextSectionElement, labelParentElememtnFilterValue);
 
                                // --------------------------------------------------------------------------------------------- //
 
 
                            }).then((resArray) => { // // this resolved value will be the index of the label of the second section that was clicked 
 
                                var resValue = resArray[0];
                                var previousLabelElement = resArray[1];
 
                                // ---------- this block sends the second section to the top and filters the labels --------------- //
                                var labelParentElememtn = dynamicQuestionnaireLabelsArray[resValue].parentElement.className.split(" ")
                                var labelParentElememtnFilterValue = labelParentElememtn[1]  //  filter value in the label element. Needed for the filterSelection function. 
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var secondQuestionHeading = document.getElementById(previousLabelElement);
                                secondQuestionHeading.style.display = "none";
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var thirdQuestionHeading = document.getElementById(labelParentElememtnFilterValue);
                                thirdQuestionHeading.style.display = "inline";
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var parentDiv = dynamicQuestionnaireLabelsArray[resValue].parentElement;
                                var section = parentDiv.parentElement;
                                var nextSectionElement = section.nextElementSibling;
                                // --------------------------------------------------------------------------------------------- //
 
 
                                //handleOtherClickedSections(resValue);
                                filterSelection(labelParentElememtnFilterValue);
 
 
                                // THIRD SECTION TYPING //
                                // ---------------- this function will place the text of the third section -------------------- //
                                return typeText(nextSectionElement, labelParentElememtnFilterValue);
                                // --------------------------------------------------------------------------------------------- //
 
 
 
 
                            }).then((resArray) => {
 
 
                                var resValue = resArray[0];
                                var previousLabelElement = resArray[1];
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var thirdQuestionHeading = document.getElementById(previousLabelElement);
                                thirdQuestionHeading.style.display = "none";
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // ---------- this block sends the third section to the top and filters the labels --------------- //
 
                                // var secondQuestionHeading = document.getElementById("secondQuestionHeading");
                                // secondQuestionHeading.style.display = "none";
 
                                var labelParentElememtn = dynamicQuestionnaireLabelsArray[resValue].parentElement.className.split(" ") // Here we are getting the class name of the div that contains the clicke label 
                                var labelParentElememtnFilterValue = labelParentElememtn[1]
                                // console.log(labelParentElememtnFilterValue);
                                //handleOtherClickedSections(resValue);
                                filterSelection(labelParentElememtnFilterValue) // This function is supposed to show the fourth section.
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var parentDiv = dynamicQuestionnaireLabelsArray[resValue].parentElement;
                                var section = parentDiv.parentElement;
                                var nextSectionElement = section.nextElementSibling;
                                // --------------------------------------------------------------------------------------------- //
 
                                // --------------------------------------------------------------------------------------------- //
                                var fourthQuestionHeading = document.getElementById(labelParentElememtnFilterValue);
                                fourthQuestionHeading.style.display = "inline";
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // FOURTH SECTION TYPING //
 
                                return typeText(nextSectionElement, labelParentElememtnFilterValue);
 
 
 
                            }).then((resArray) => {
 
 
                                var resValue = resArray[0];
                                var previousLabelElement = resArray[1];
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var labelParentElememtn = dynamicQuestionnaireLabelsArray[resValue].parentElement.className.split(" ");
                                var labelParentElememtnFilterValue = labelParentElememtn[1];
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var fourthQuestionHeading = document.getElementById(previousLabelElement);
                                fourthQuestionHeading.style.display = "none";
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var fifthQuestionHeading = document.getElementById(labelParentElememtnFilterValue);
                                fifthQuestionHeading.style.display = "inline";
 
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var parentDiv = dynamicQuestionnaireLabelsArray[resValue].parentElement;
                                var section = parentDiv.parentElement;
                                var nextSectionElement = section.nextElementSibling;
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                //handleOtherClickedSections(resValue);
                                filterSelection(labelParentElememtnFilterValue);
                                // --------------------------------------------------------------------------------------------- //
 
 
 
 
 
                                // FIFTH SECTION TYPING //
 
 
 
                                return typeText(nextSectionElement, labelParentElememtnFilterValue);
 
 
                            }).then((resArray) => {
 
                                var resValue = resArray[0];
                                var previousLabelElement = resArray[1];
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var labelParentElememtn = dynamicQuestionnaireLabelsArray[resValue].parentElement.className.split(" ");
                                var labelParentElememtnFilterValue = labelParentElememtn[1];
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var fifthQuestionHeading = document.getElementById(previousLabelElement);
                                fifthQuestionHeading.style.display = "none";
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var sixthQuestionHeading = document.getElementById(labelParentElememtnFilterValue);
                                sixthQuestionHeading.style.display = "inline";
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var parentDiv = dynamicQuestionnaireLabelsArray[resValue].parentElement;
                                var section = parentDiv.parentElement;
                                var nextSectionElement = section.nextElementSibling;
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                // handleOtherClickedSections(resValue);
                                filterSelection(labelParentElememtnFilterValue);
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // SIXTH SECTION TYPING //
 
                                return typeText(nextSectionElement, labelParentElememtnFilterValue);
 
 
                            }).then((resArray) => {
 
                                var resValue = resArray[0];
                                var previousLabelElement = resArray[1];
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var labelParentElememtn = dynamicQuestionnaireLabelsArray[resValue].parentElement.className.split(" ");
                                var labelParentElememtnFilterValue = labelParentElememtn[1];
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var sixthQuestionHeading = document.getElementById(previousLabelElement);
                                sixthQuestionHeading.style.display = "none";
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var seventhQuestionHeading = document.getElementById(labelParentElememtnFilterValue);
                                seventhQuestionHeading.style.display = "inline";
 
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var parentDiv = dynamicQuestionnaireLabelsArray[resValue].parentElement;
                                var section = parentDiv.parentElement;
                                var nextSectionElement = section.nextElementSibling;
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                // handleOtherClickedSections(resValue);
                                filterSelection(labelParentElememtnFilterValue);
                                // --------------------------------------------------------------------------------------------- //
 
                                // SEVENTH SECTION TYPING //
 
                                return typeText(nextSectionElement, labelParentElememtnFilterValue);
 
 
 
                            }).then((resArray) => {
 
                                var resValue = resArray[0];
                                var previousLabelElement = resArray[1];
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var labelParentElememtn = dynamicQuestionnaireLabelsArray[resValue].parentElement.className.split(" ");
                                var labelParentElememtnFilterValue = labelParentElememtn[1];
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var seventhQuestionHeading = document.getElementById(previousLabelElement);
                                seventhQuestionHeading.style.display = "none";
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var eigthQuestionHeading = document.getElementById(labelParentElememtnFilterValue);
                                eigthQuestionHeading.style.display = "inline";
 
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var parentDiv = dynamicQuestionnaireLabelsArray[resValue].parentElement;
                                var section = parentDiv.parentElement;
                                var nextSectionElement = section.nextElementSibling;
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                // handleOtherClickedSections(resValue);
                                filterSelection(labelParentElememtnFilterValue);
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                // EIGTH SECTION TYPING //
                                return typeText(nextSectionElement, labelParentElememtnFilterValue);
 
 
                            }).then((resArray) => {
 
                                var resValue = resArray[0];
                                var previousLabelElement = resArray[1];
 
 
 
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var labelParentElememtn = dynamicQuestionnaireLabelsArray[resValue].parentElement.className.split(" ");
                                var labelParentElememtnFilterValue = labelParentElememtn[1];
                                // --------------------------------------------------------------------------------------------- //
 
                                // --------------------------------------------------------------------------------------------- //
                                var eigthQuestionHeading = document.getElementById(previousLabelElement);
                                eigthQuestionHeading.style.display = "none";
                                // --------------------------------------------------------------------------------------------- //
 
 
                                // --------------------------------------------------------------------------------------------- //
                                var ninthQuestionHeading = document.querySelector("." + labelParentElememtnFilterValue);
                                ninthQuestionHeading.style.display = "inline";
                                // --------------------------------------------------------------------------------------------- //
 
 
 
                                //handleOtherClickedSections(resValue);
                                filterSelection(labelParentElememtnFilterValue); // <=====----- 
 
 
                            })
 
                    })
                }
 
 
            }
 
 


    /*
 
        // ======================================================================================= //
        // ======================================================================================= //
        // ======================================================================================= //
        // ======================================================================================= //
        // ======================================================================================= //
        // ======================================================================================= //
        // ======================================================================================= //
        // ======================================================================================= //
        // ======================================================================================= //
        // ======================================================================================= //
 
 
        // --- ADD AN EVENT LISTENER TO THE REASON ARROW --- //
        // THIS EVENT LISTENER WILL CREATE A TOOLTIP NEXT TO THE PLACE, AND WILL FORMAT THE "REASON" TEXT INSIDE THE TOOLTIP. 
 
        var toolTipHeightGlobal = []
 
        reasonArrow.addEventListener("click", () => {
 
            console.log(placeCoords);
 
            const reason = reasonArrow.previousElementSibling.value; // Reason value 
            const address = addressArrow.previousElementSibling.value; // Address value 
            const name = nameArrow.previousElementSibling.value; // Name value
 
            var tooltipDiv = document.getElementById("tooltip"); // Here we select the div where the div will go (which I am actually not using)
 
            // getPlaceInfo(address, (error, response) => {
            // var coords = [response.items[0].position];
            // var divLeftStyle = projection([coords[0].lng.toString(), coords[0].lat.toString()])[0]
            // var divTopStyle = projection([coords[0].lng.toString(), coords[0].lat.toString()])[1]
 
 
            var string = reason;
            var lines = Math.ceil(string.length / 6); // 5 lines 
            let i = 1;// used to iterate over "lines".
            let initialSlice = 0; // start of the initial "string" cut.
            let lastChar = 60; // inidicates the last character of the final cut.
            var stringArray = []; // this is where we will be storing the slices of the "string"
            let fullIterationString = ""; //we will use this to know when "stringArray" is the same as "string"
            let stringLine = "";// this will be used to hold all the slices of "string"
            let difference = 0;
 
            // "fullIterationString" will start as an empty string. 
            // "string" is the text that we will be typing. 
            while (fullIterationString != string) {
 
                stringLine = string.slice(initialSlice, lastChar) // "initialSlice" will start as 0. "lastChar"  is 60
                // In the "slice" function, >>>> the first argument represents the start <<<< --- >>>> the second argument represents the finish <<<<
                // "slice" slices the string from start to end (THE END IS NOT INCLUDED).
 
                fullIterationString += stringLine; // "fullIterationString" is being passed the string from character 0 to character 59 
 
                if (stringLine.charAt(stringLine.length - 1) != " ") { // Here we are saying that "if the last character of 'stringLine' is not equal to an empty space, then do the following: "
 
                    difference = string.length - fullIterationString.length; // We are getting the difference between full "string" and "fullIterationString (represents the string from character 0 to character 60)" 
 
                    let iteration = 1;
                    // ========================================================= //
                    for (iteration; iteration <= difference; iteration++) { // We will start a loop for as many characters in the full "string" are not included in "fullIterationString".
                        lastChar += 1
                        stringLine = string.slice(initialSlice, lastChar); // "stringLine" was initially set to be the full "string" from character 0 to character 60. Here we are adding one more character from the
                        fullIterationString += stringLine.charAt(stringLine.length - 1); // up to here "fullIterationString" was the full string from character 0 to character 59. Here we are adding one more character to it from the full "string".
 
                        // WE HAVE GOTTEN UP TO THIS POINT IF THE FOLLOWING CONDITIONS TAKE PLACE:
                        // 1 - "fullIterationString" IS DIFFERENT FROM THE FULL "string" (WHICH AT FIRST IT WILL OBVIOULY BE THE CASE).
                        // If the previous is fulfilled, "fullIterationString" will be equal to the full "string" from character 0 to character 59
 
                        // 2 - IF THE LAST CHARACTER OF "stringLine (full string from 0 to 59 initially)" IS NOT AN EMPTY SPACE.
                        // If the previous is fulfilled, "fullIterationString" is going to be added one more character. 
 
 
 
                        if (stringLine.charAt(stringLine.length - 1) === " ") {
                            // if the last character of "stringLine" is equal to an empty space " ", then we will break out of this loop, and outside the IF statement, we will --> stringArray.push(stringLine);
                            initialSlice = fullIterationString.length;
                            lastChar = initialSlice + 60;
                            break;
                        }
                    }
                    // ========================================================= //
                } else {
 
                    //If "stringLine(full string from character 0 to char 59)" IS ACTUALLY EQUAL TO AN EMPTY SPACE:
                    // 1. "initialSlice (initially set to 0)" will be set to the length of "fullIterationString (set to "string" from 0 to 59 outside this IF statement.)" 
                    // 2. We will add 60 to "lastChar"
 
                    // Basically, we will be changing the INITIAL and LAST character 
 
                    initialSlice = fullIterationString.length;
                    lastChar = initialSlice + 60;
 
                }
 
                // "stringArray" is an empty array. 
                // On this line below, we are pushing "stringLine (full string from char 0 to char 59 if if landed on an empty space or until it lands an empty space.)"
                stringArray.push(stringLine);
            }
 
            var textIteration = 0;
            var leftSyle = 30;
            var topStyle = 25;
            var stringArrayLength = stringArray.length;
 
            // ------------------------------------ //
            var toolTipHeight = (stringArrayLength * 36) + 45
            toolTipHeightGlobal.push(toolTipHeight);
 
 
            function createTooltip(heigh, width) {
                var rect = map.append("rect")
                    .attr("x", placeCoords[0])
                    .attr("y", placeCoords[1])
                    .attr("height", heigh)
                    .attr("width", width)
                    .attr("id", "rect")
                    .style("fill", "black")
            }
            createTooltip(toolTipHeight, 545)
            // ------------------------------------ //
 
            for (textIteration; textIteration < stringArray.length; textIteration++) {
                topStyle += 22
 
                map.append("text")
                    .attr("x", placeCoords[0] + leftSyle)
                    .attr("y", placeCoords[1] + topStyle)
                    .text(stringArray[textIteration])
                    .style('fill', 'white')
                console.log(stringArray.length);
            }
 
        })
        // })
 
 
 
 
 
        // --- ADD AN EVENT LISTENER TO THE REASON ARROW --- //
 
        imageArrow.addEventListener("click", () => {
 
            //var imageTooltip = document.getElementById("imageTooltip"); // <========== This is a div ======> <div id="imageTooltip"></div>
            //image.style.left = placeCoords[0];
            //image.style.top = placeCoords[1];
 
 
 
            // 1. create the canvas where the image will go:
            var imageCanvas = document.createElement("canvas");
 
            // 2. add a context to that canvas:
            let context = imageCanvas.getContext("2d");
 
 
            // 3. Create an element that will get the image input element:
            var imageInput = document.querySelector("#image");
 
            // 4. make sure that there is a file loaded in the imageInput, and if so execute some code 
 
            function showImage() {
                if (imageInput.files && imageInput.files[0]) {
 
                    // 5. Use the FileReader method:
                    let reader = new FileReader();
 
                    // 7. Code that will be triggered once "reader" reads the image file:
                    reader.onload = () => {
 
                        // 8. use new Image(), which will create a new HTML image element:
                        let image = new Image();
 
                        image.onload = () => {
 
                            //10. resize the canvas element so that it reflects the height and width of the height and width of the submitted image:
                            imageCanvas.height = image.height;
                            imageCanvas.width = image.width;
 
                            context.clearRect(0, 0, imageCanvas.height, imageCanvas.width);
                            context.drawImage(image, 0, 0);
 
                        }
                        // 9. create the USV string that will reflect the image src method:
                        image.src = reader.result;
 
                        //console.log(reader.result);
                    }
                    // 6. User the FileReader method to read file that uploaded by the user and that lives insise "imageInput":
                    reader.readAsDataURL(imageInput.files[0]);
                }
            }
 
 
            // var image = showImage();
            // console.log(image.result); // -> undefined. 
 
 
 
 
            //console.log(imageTooltip);
 
 
            // 1. innerHTMl has to go inside a "canvas" element. "showImage" will have to be passed to canvas.innerHTML.
            // 2. once the image canvas is passed the "showImage()" function, we will have to append the canvas as a child of "imageTooltip", which looks like this: <div id="imageTooltip"></div>
 
 
            var createImageTooltip = function () {
 
                //imageCanvas.toBlob(showImage());
                // imageCanvas.innerHTML = showImage();
                //var canvasData = imageCanvas.toDataURL()
 
                //const newDiv = document.createElement("div");
 
 
                var imageRect = map.append("rect")
                    .attr("x", placeCoords[0])
                    .attr("y", placeCoords[1] + toolTipHeightGlobal[0] + 5)
                    .attr("height", 400)
                    .attr("width", 545)
                    .attr("id", "imageTooltipRect")
                    .style("fill", "black")
                    .style("opacity", 0.3)
 
                //.html("<img width='400' height='321' src=" + imageCanvas.toDataURL() + ">")
 
 
                
                //var divImage = map.insert("rect")
                //    .attr("x", placeCoords[0])
                //    .attr("y", placeCoords[1] + toolTipHeightGlobal[0] + 5)
                //    .attr("height", 400)
                //    .attr("width", 545)
                //    .style("fill", "black")
                //    .style("opacity", 0.3)
                //    .html("<canvas width='400' height='321'>" + showImage())
                
 
 
                //.html("<img width='400' height='321' src=" + imageCanvas.toDataURL() + ">")
 
                // imageDivRect[0].appendChild(imageCanvas);
 
 
                // newDiv.style.left = placeCoords[0];
                // newDiv.style.top = placeCoords[1];
 
                // map.append (imageTooltipDiv);
                //imageTooltip.appendChild(imageCanvas);
 
 
                //console.log(imageDivRect[0]); // This prints well 
                //console.log(imageDivRect); // this prints an HTML
                //console.log(newDiv); // this prints well 
 
 
                // imageDivRect.append(imageCanvas);
                // imageRect.appendChild(newDiv); // not working because "imageRect" is not a Dom element 
                // imageRect.appendChild(imageTooltipDiv); // This is not appending to "imageRect" because imageTooltipDiv is already created in the HTML document so it cannot be appended to another element.
 
 
                // d3.select(".imageToolTip").append("div")
                //    .html(imageCanvas)
 
 
                // var imageDiv = imageRect.append("div")
                //     .attr("class", "imageDivRect")
                //.html(showImage())
 
                // imageDiv.appendChild(imageCanvas);
 
                //map.append(imageCanvas);
 
                //var imageCanvas_ = imageRect.insert("svg")
                //    .attr("class", "imageCanvas")
                //    .html(showImage())
                //.innerHTML(showImage())
 
                // imageDivRect.appendChild(document.createElement('b'));
 
 
 
                var imageTooltipRect = document.getElementById("imageTooltipRect") // This is the rect element we need the coords of. We appended this element from d3.js .
 
                var imageDivRect = document.getElementById("imageTooltip"); // This is the div element that need to move on the the screen, which was created in the HTML document.  
 
                var photoXposition = imageTooltipRect.getBoundingClientRect().left
                var photoYposition = imageTooltipRect.getBoundingClientRect().top
 
                imageDivRect.style.position = "absolute";
                imageDivRect.style.left = photoXposition + "px";
                imageDivRect.style.top = photoYposition + "px";
 
                console.log(photoXposition);
                console.log(photoYposition);
 
                imageCanvas.innerHTML = showImage();
                imageDivRect.appendChild(imageCanvas); // <======== imageTooltip is a div: ======> <div id="imageTooltip"></div>
 
            }
 
            createImageTooltip()
 
            // setTimeout(createImageTooltip(), 3000)
 
            //var imageRectGlobal = document.getElementsByClassName("imageToolTip"); // this is a rect 
            //imageRectGlobal[0].appendChild(imageCanvas); // not doing anything. 
 
 
        })
 
 
 
        // ------------ ADD AN EVENT LISTENER TO THE SUBMIT BUTTON ------------ //
        const form = document.getElementById("form2");
        form.addEventListener("submit", function (e) {
            e.preventDefault()
            var mapDiv = document.getElementById("mapDiv")
 
            // mapDiv.style.transform = "translateY(" + 1000 + "px)";
 
            var feed = document.getElementById("feed");
 
            var initialForm = document.getElementById("form2");
            var name = initialForm.elements.text.value;
            var reason = initialForm.elements.reason.value;
            var placeAddress = initialForm.elements.address.value;
 
            var imageInput = document.querySelector("#image"); // <<<< image selector. 
 
            getPlaceInfo(placeAddress, (error, response) => {
 
                var coords = [response.items[0].position]
                var circle = map.append("circle")
                    .attr("cx", projection([coords[0].lng.toString(), coords[0].lat.toString()])[0])
                    .attr("cy", projection([coords[0].lng.toString(), coords[0].lat.toString()])[1])
                    .attr("r", 6)
                    .attr("fill", "blue");
 
 
                var values = {
                    "name": name,
                    "address": placeAddress,
                    "reason": reason,
                    "coordinates": coords,
                }
 
                //console.log("values", values);
 
 
 
                // ===================================================================//
                // ===================================================================//
                // ========  USING FormData() TO UPLOAD FILES VIA FETCH API ========= //
                // ===================================================================//
                // ===================================================================//
                // ===================================================================//
                // ===================================================================//
                // ========  USING FormData() TO UPLOAD FILES VIA FETCH API ========= //
                // ===================================================================//
                // ===================================================================//
                // ===================================================================//
                // ===================================================================//
                // ========  USING FormData() TO UPLOAD FILES VIA FETCH API ========= //
                // ===================================================================//
                // ===================================================================//
                // ===================================================================//
                // ===================================================================//
                // ========  USING FormData() TO UPLOAD FILES VIA FETCH API ========= //
                // ===================================================================//
                // ===================================================================//
 
                // ---------- HEADERS  ---------- //
                // ---------- HEADERS  ---------- //
                // ---------- HEADERS  ---------- //
                // ---------- HEADERS  ---------- //
 
                let h = new Headers();
                h.append("Accept", "application/json");
 
                let fd = new FormData();
 
                fd.append("name", name);
                fd.append("address", placeAddress);
                fd.append("reason", reason);
                fd.append("coordinates", JSON.stringify(coords));
                let sitePhoto = document.getElementById("image").files[0];
                fd.append("image", sitePhoto);
 
                let req = new Request("/status/input", {
                    method: "POST",
                    headers: h,
                    mode: "no-cors",
                    body: fd
                });
 
                console.log("req", req);
 
                fetch(req)
 
 
                // ===================================================================//
                // ===================================================================//
                // ===================================================================//
                // ===================================================================//
 
 
 
                // ===== CREATE DOM ELEMENTS TO DISPLAY THE USER INPUT DATA ===== //
 
                var author = document.createElement("p");
                author.innerHTML = "Published by: " + name;
 
                var address = document.createElement("p");
                address.innerHTML = "Address: " + placeAddress;
 
                var table = document.createElement("table");
                table.setAttribute = ("id", "placeTable");
 
                var tableContReason = document.createElement("td");
                tableContReason.innerHTML = reason;
 
                // ===  CREATE THE CANVAS === //
                var canvasTD = document.createElement("td")
                canvasTD.style.verticalAlign = "middle";
 
                var tableCanvas = document.createElement("canvas");
                //ableCanvas.style.height = "480px";
                //tableCanvas.style.width = "640px";
                tableCanvas.innerHTML = showPhoto();
 
                canvasTD.appendChild(tableCanvas);  // <<<<<<
 
                // tableCanvas.style.height = "1000px"; // <<<<<<
                // tableCanvas.style.width = "1000px";  // <<<<<<
 
                // canvasTD.style.height = "1000px";  // <<<<<<
                // canvasTD.style.width = "1000px";  // <<<<<<
 
 
 
                function resizeCanvas(canvasHeight, canvasWidth) {
 
                    let height = canvasHeight;
                    let width = canvasWidth;
 
                    tableCanvas.style.height = height + "px";
                    tableCanvas.style.height = width + "px";
 
                    canvasTD.style.height = height + "px";
                    canvasTD.style.width = width + "px";
 
                    if (height > 550 && width > 730) {
                        height /= 2;
                        width /= 2;
 
                        tableCanvas.style.height = height + "px";
                        tableCanvas.style.height = width + "px";
 
                        canvasTD.style.height = height + "px";
                        canvasTD.style.width = width + "px";
                    }
                }
 
 
                function showPhoto() {
                    let context = tableCanvas.getContext("2d");
                    if (imageInput.files && imageInput.files[0]) {
                        let reader = new FileReader();
                        reader.onload = () => {
                            let image = new Image();
                            image.onload = () => {
 
                                console.log("image.height", image.height);
                                console.log("image.width", image.width);
 
                                tableCanvas.height = image.height;
                                tableCanvas.width = image.width;
 
                                // canvasTD.height = image.height; // <<<<<<
                                // canvasTD.width = image.width;  // <<<<<<
 
                                context.clearRect(0, 0, tableCanvas.height, tableCanvas.width);
                                context.drawImage(image, 0, 0);
 
                                resizeCanvas(image.height, image.width);
                            }
                            image.src = reader.result;
                        };
                        reader.readAsDataURL(imageInput.files[0]);
                    }
                }
 
                // imageInput.addEventListener("change", showPhoto()) //<<<<<<<<< Cannot read property 'addEventListener' of null 
 
 
                //tablePhoto.innerHTML = "Here we will put a photo";
 
                table.appendChild(tableContReason);
 
                table.appendChild(canvasTD);  // <<<<<<
 
                feed.appendChild(author);
                feed.appendChild(address);
                feed.appendChild(table);
 
 
                // window.scrollTo(0, 1000);
 
 
            })
        })
 
 
 
 
 
 
 
 
 
                /////////////////////
        //------------ READ THE DATA OF THE POINTS OF INTEREST TO BE DISPLAYED------------//
        d3.csv('pointsOfInterest.csv', function (places) {
 
            //------------CREATE THE FUNCTION THAT WILL DISPLAY THE TOOLTIP---------------//
            var hoverPoints = function (d) {
                //------------CREATE THE DIMENSIONS AND POSITION OF THE TOOLTIP-----------//
                var toolTipDiv = document.getElementById("tooltip")
                toolTipDiv.style.left = event.pageX + 16 + "px";
                toolTipDiv.style.top = event.pageY + 16 + "px";
                toolTipDiv.style.background = "green";
                // div.style.width = 400 + d.name.length + "px";
                toolTipDiv.style.width = 460 + "px";
                //var wordLength = d.name.split(' ').length;
                //div.style.height = 240 + "px";
                toolTipDiv.style.height = 300 + "px";
                toolTipDiv.style.opacity = "1";
                toolTipDiv.innerHTML = d.name;
 
                console.log("cx", projection([d.lon, d.lat])[0]) // This console logs the values to be displayed on the map 
                console.log("cy", projection([d.lon, d.lat])[1])
 
                //----CALL THE FUNCTION THAT WILL DISPLAY THE LINE INSIDE THE TOOLTIP-----//
                //showGraph(d.name);
 
            }
            //--------- CREATE THE FUNCTIONS THAT WILL MAKE THE TOOLTIP DISSAPEAR ---------//
            var hoverPointsOut = function () {
                var div = document.getElementById("tooltip")
                div.style.transition = "all .3s";
                div.style.opacity = "0";
            }
 
            //--------- DISPLAY THE POINTS ON THE MAP ---------//
            var points = map.selectAll("circle").data(places);
            var text = map.selectAll("text").data(places);
            var radius = d3.scaleLinear().domain([0, 500000]).range([5, 30])
 
            points.enter()
                // The x and y coordinates are determined by calling our previous projection() function with the corresponding latitude and longitude coordinates from the data file.
                // Note that the projection() function returns an array of x and y coordinates (x, y). The x coordinate is determined by taking the 0 index of the returned array. The y coordinate is determined from the index, 1.
                .append("circle")
                .attr("cx", function (d) { return projection([d.lon, d.lat])[0] })
                .attr("cy", function (d) { return projection([d.lon, d.lat])[1] })
                .attr("r", 1.8)
                .attr("fill", "red")
                .on("mouseover", hoverPoints)
                .on("mouseout", hoverPointsOut);
 
 
            // The x and y coordinates are determined by calling our previous projection()
            // Note that the projection() function returns an array of x and y coordinates (x, y).
            // The x coordinate is determined by taking the 0 index of the returned array. 
            // The y coordinate is determined from the index, 1 
 
            text.enter()
                .append("text")
                .attr("x", function (d) { return projection([d.lon, d.lat])[0] })
                .attr("y", function (d) { return projection([d.lon, d.lat])[1] })
                .attr("dx", 5)
                .attr("dy", 3)
                .text(function (d) { return d.name })
        })
        /////////////////////
 
    })
 
    */




/*
    //------------------------- WEBSOCKETS ---------------------------//
    var wsUri = "ws://localhost:8080";
    var ws = new WebSocket(wsUri);
    ws.onopen = function (evt) {
        console.log("1. Connected (from Client)")
    }
    ws.onmessage = function (message) {
        var messageArray = JSON.parse(message.data)
        console.log("5. This is the list of user names:", messageArray)
        var lastName = messageArray[messageArray.length - 1]
        if (typeof messageArray != "object") { // This lets us only send the username to the funciton "listOfUsers"
            listOfUsers(messageArray);
        }
    }
    //-------------------FUNCTIONS FOR WEBSOCKET-------------------//

    function sendUserName() {
        var name = document.getElementById("username").value;
        ws.send(JSON.stringify(name))
        var userNameDiv = document.getElementById("userName")
        var userName = document.createElement("p")
        userName.innerHTML = "Your user name is: " + name
        userNameDiv.appendChild(userName)
    }
    function listOfUsers(name) {
        var node = document.createElement("LI")
        var textNode = document.createTextNode(name)
        node.appendChild(textNode)
        document.getElementById("listOfUsers").appendChild(node);
    }
    function showContent() {
        var dropDown = document.getElementById("listOfUsers")
        dropDown.classList.toggle("show");
        // .classList.add("show");
        // dropDown.style.display = "block"
    }
    function sendAddress() {
        var locations = {}
        var value = document.getElementById("favPlace").value;
        locations.address = value
        ws.send(JSON.stringify(locations))
        console.log(typeof locations)

    }
*/



    //======== THE FOLLOWING BLOCK WILL ADD MOUSE OVER AND MOUSEOUT EVENTS THAT CHANGE THE COLOR OF THE LABELS ========//
    /*
    Array.from(document.getElementsByClassName('filterDiv')).forEach(element => {
        element.addEventListener("mouseover", function () {
            element.style.background = "pink";
        })
        element.addEventListener("mouseout", function () {
            element.style.background = "lightblue";
        })
    })


    */
    //===========================================================================================//




// This prototype may have to be different for the first label.

function typeText() {

    return new Promise((resolve, reject) => {

        for (var i = 0; i < dynamicQuestionnaireLabelsArray.length; i++) {

            dynamicQuestionnaireLabelsArray[i].children[0].addEventListener("click", function () {

                let labelText = dynamicQuestionnaireLabelsArray[i].textContent.replace(/[\n\r]+|[\s]{2,}/g, ' ').trim()
                let typedTextParagraph = document.getElementById("typedText"); //I need to add " placeRelationStatus " here. 
                typedTextParagraph.innerHTML = typedTextParagraph.innerHTML + " "
                let brokenText = typedTextParagraph.innerHTML.split("<br>");
                let lastLineText = brokenText[brokenText.length - 1];


                function typeDelay(i, u, newText) {
                    setTimeout(() => {
                        newText += labelText.charAt(u);
                        typedTextParagraph.innerHTML = typedTextParagraph.innerHTML + labelText.charAt(u);
                        u++;
                        i++;
                        if (newText === labelText) {
                            resolve(currentLabel);
                        } else {
                            typeChars(i, u, newText);
                        }
                    }, 50);
                }

                function typeChars(i, u, newText) {
                    if (i < 52) {
                        typeDelay(i, u, newText);
                    } else if (i >= 52 && typedTextParagraph.innerHTML.charAt(typedTextParagraph.innerHTML.length - 1) != " ") {
                        typeDelay(i, u, newText);
                    } else if (i >= 52 && typedTextParagraph.innerHTML.charAt(typedTextParagraph.innerHTML.length - 1) === " ") {
                        typedTextParagraph.innerHTML += "<br>";
                        i = 0;
                        typeChars(i, u, newText);
                    }
                }
                let newText = "";
                typeChars(lastLineText.length, 0, newText);
            })
        }
    })
}



///=====================



const WebSocket = require("ws");

//================== WEBSOCKETS ==================//
wss = new WebSocket.Server({ port: 8080 });
/*
wss.broadcast = function broadcast(data, sentBy) {
    for (var i in this.clients) {
        if (this.clients[i] != sentBy) {
            this.clients[i].send(data)
        }
    }
}
*/
var allNames = []
wss.on("connection", function connection(ws) { // This event listener is triggered when whe connection between the client and the server is established. 
    console.log("2. Connected (from Server)")
    var names = [];
    ws.on("message", function incomming(message) {
        message = JSON.parse(message);
        if (typeof message === "object") {
            console.log("yiiiiiiijjjj")
        }
        console.log("3. received frome the Client ", message);
        names.push(message);
        console.log("4. List of names", names)
        //ws.send(JSON.stringify(names));
        //wss.broadcast(names, this); // <===--- the data is not arriving with this 
        wss.clients.forEach(function each(client) {
            if (client.readyState === WebSocket.OPEN) {
                // allNames.push(names)
                client.send(JSON.stringify(message));
                console.log("7. All names connected: ", message)
                // client.send(JSON.stringify(names));
            }
        })
        //  allNames.push(names)
        //  
    })
    //ws.send("Connected");
})

//====================================================//


///=====================


const fs = require("file-system");  // This will be used to read and write to files. 


  //res.send(formatedImages); // <=== This displays both images on the browser. 

        //res.sendFile("userinputs", {roor:__dirname}); // <=== I was previously using this to send an HTML file. 


        /* ************************************************************************ */
        // const writeStream = fs.createWriteStream("output/fileData.txt"); // 1. open a writestream 
        // 2. pipe the writestream to the http response. img1 and img2 are the http response. 
        // writeStream.write(img1)
        // writeStream.write(img2)

        // THE FOLLOWING CODE WILL DISPLAY JUST ONE IMAGE ON THE CLIENT SIDE. 
        //images.forEach((str) => {
        //    writeStream.write(str)
        //})
        //writeStream.end();
        //const readStream = fs.createReadStream("output/fileData.txt");
        //readStream.pipe(res); // readableSrc.pipe(writableDest)


        // When piping, The source has to be a readable stream and the destination has to be a writable one.
        // if I do writeStream.pipe(res), I get ===> Error [ERR_STREAM_CANNOT_PIPE]: Cannot pipe, not readable
        /*  ************************************************************************ */



        /* ************************************************************************ */
        //         THE FOLLOWING SENDS JUST ONE IMAGE TO THE CLIENT SIDE
        // THE FOLLOWING CODE WILL DISPLAY THE BINARY DATA ON THE BROWSER.
        //res.writeHead(200, {
        //    "Content-Type": "image/png",
        //    //"Content-Length": img1.length,
        //})

        //var i = 0;
        //for (i; i <= images.length; i++) {
        //    res.json(images[i]);
        //}
        /*  ************************************************************************ */




        //res.end(img1);
        // console.log(typeof records[0].img.data); ===> prints object
        //console.log(images); // This prints all the records correctly. 
        //console.log(imgs); // printing undefined.
        //console.log(Buffer.isBuffer(imgs)); // ===> This prints "true"
        //console.log(imgs); // This prints ===> <Buffer 00 00>
        //res.send(images);
        // res.send(records);
        // console.log(records[0])



// === CREATE THE POST REQUEST WHICH IS USED TO HANLDE THE DATA THAT IS SUBMITTED BY THE USER === //



app.post("/status/input", upload.single("image"), (req, res) => {



    console.log("req.file", req.file)

    let newRecord = new Image()
    newRecord.user = req['body']['name'];
    newRecord.address = req['body']['address'];
    newRecord.placeMeaning = req['body']['reason'];
    newRecord.coordinates = JSON.parse(req['body']['coordinates']);
    newRecord.img.data = fs.readFileSync(req.file.path);
    newRecord.img.contentType = "image/png";

    console.log("newRecord", newRecord);

    newRecord.save();

    /*
    newRecord.save((error, record) => {
        if (error) {
            res.send(error);
        } else {
            res.send(record);
        }
    })
    */

})

// ==============

const mustache = require("mustache-express");



const util = require("util");

//=================================================////=============================================================//
//===== CODE FOR INSERTING FILES INTO MONGODB =====////=============================================================//
//=================================================////=============================================================//
/* 
const storage = new GridFsStorage({ // 1.
    url: "mongodb://127.0.0.1:27017/CB2BXSocialPlatform", // 2.
    options: { useNewUrlParser: true, useUnifiedTopology: true }, // 3.
    file: (req, file) => {
        return {
            bucketName: "photos",
            filename: `${Date.now()}-CB2SocialPlatform-${file.originalname}`
        }
    }
})


const upload = multer({ storage: storage }).single("image"); // 4.
var uploadFilesMiddleware = util.promisify(upload); // 5.
const uploadFile = async (req, res) => { // 6. 
}
*/
//=================================================//
//=================================================//
//=============================================================//
//==CREATING THE UPLOAD MIDDLEWARE WITH MULTER.DISKSTORAGE====//
//=============================================================//
/* 
const storage = multer.diskStorage({ // This storate negine defines where to store the images and what name to give them.
    destination: "uploads/",
    filename: function (req, file, cb) {
        cb(null, file.fieldname + "-" + Date.now() + path.extname(file.originalname));
    }
})
const upload = multer({
    storage: storage
}).single("image");
*/
//=============================================================////=============================================================//
//=============================================================////=============================================================//


//============================================================= MULTER =============================================================//
//=============================================================////=============================================================//


const multer = require("multer"); // Node.js Middleware for handling. It is primarily used for uploading files.
const GridFsStorage = require("multer-gridfs-storage");


var storage = multer.diskStorage({
    destination: "uploads/",
    filename: (req, file, cb) => {
        cb(null, file.fieldname + "-" + Date.now())
    }
})


var upload = multer({ storage: storage });


//var upload = multer({ dest: "uploads/" });


//================================//



//-----------------------------------------------------//
//Express:

/* 
app.post("/status/input", function (req, res) { // We'll use this route to post the data from the form.

    // Including the "upload" middleware on the top allowed me to access both the text and the image data.


    // ======================================= //
    // === CODE TO GET AND RETREIVE IMAGES === //
    // ======================================= //



    // ====================================== //
    // ======================================= //
    // ======================================= //



    var imagePath = req.file.path.replace(/^uploads\//, "");
    res.redirect = imagePath;
    console.log(imagePath);
    // Redirects to the URL derived from the specified path, with specified status,
    // a positive integer that corresponds to an HTTP status code . 
    // If not specified, status defaults to “302 “Found”.


    let status = {
        'name': req['body']['name'],
        'address': req['body']['address'],
        'reason': req['body']['reason'],
        'coordinates': JSON.parse(req['body']['coordinates']),
        'image data': req.file
    }

    console.log("status", status);

    var dataToSend = JSON.stringify(status);

    fs.writeFile(__dirname + "/posts.json", dataToSend, function (err) { // The "name" is going to be the user's name. "status" will be what the user wrote about their favorite place.

    })





    // ==== MONGODB CONN ==== //
    mongoClient.connect(url, { useUnifiedTopology: true }, function (err, client) {
        let db = client.db("CB2BXSocialPlatform");


        let inputs = db.collection("UserInputs");
        inputs.insertOne({
            timestamp: new Date(),
            name: status["name"],
            reason: status["reason"],
            address: status["address"],
            coordinates: status["coordinates"]
        })


     //.............................................//
        var storage = new GridFsStorage({ //GridFsStorage is an instance of MULTER-GRIDFS-STORAGE, which is an engine for MULTER to store uploaded files directly to MongoDB.

            // url is only rquiered if db is not present. 
            db: db,
            file: (req, file) => {
                const match = ["image/png", "image/jpeg"];
                if (match.indexOf(file.mimetype) === -1){
                    const filename = `${Date.now()}-CB2SocialPlatform-${file.originalname}`;
                    return filename;
                }
                return {
                    bucketName : "Photos",
                    filename :`${Date.now()}-CB2SocialPlatform-${file.originalname}`
                }
            }
        })
        var uploadFile = multer({storage:storage}).single("image")
        var uploadFilesMiddleware = util.promisify(uploadFile);
        const uploadFile_ = async (req, res)=>{
            try{
                await uploadFilesMiddleware(req, res);
                console.log(req.file);
                if(req.file == undefined){
                    return res.send("You must select a file.");
                }
                return res.send("Your file has been uploaded.");
            } catch (error){
                console.log(error);
                return res.send(`Error when trying to upload the image ${error}`)
            }
        }
        uploadFile_();
     //.............................................//
       
    })

    //A Promise is always in one of the following states:

    //      - fulfilled: Action related to the promise succeeded.
    //      - rejected: Action related to the promise failed.
    //      - pending: Promise is still pending i.e not fulfilled or rejected yet.
    //      - settled: Promise has fulfilled or rejected


})

*/


const ejs = require("ejs");
app.use(bodyParser.urlencoded({ extended: true }));




app.set("view engine", "ejs"); //<=== Here we are saying that we will be rendering an "html" file.  
app.set("views", "./views"); // <=== This is the folder where the "index.html" file is located 




app.post("/send_data", (req, res, next) => {

    console.log(req.body);
    console.log(req.params);

    res.write(

        JSON.stringify({
            sucess: true,
            data: [{ id: 3, text: "test" }]
        })
    )

});


// === CREATE A GET REQUEST THAT WILL DISPLAY ALL IMAGES IN THE DATABASE === //

app.get("/showallimages", (req, res) => {


    Image.find({}).exec((error, records) => {


        // var images = []
        // records.forEach((r) => { images.push(r.img) })
        // var imgs = Buffer.from(images, "base64"); // "base64" will encode any bit stream as a sequence of 7-bit ASCII characters, like Binary Data to plain text. 
        // - Base64 ====> string encoding. 
        // - A buffer is a region of a physical memory storage used to temporarily store data while it is being moved from one place to another. 
        // var imgs = records.forEach((r) => { Buffer.from(r.img.data, "base64") }); // ---> did not work.



        var img1 = Buffer.from(records[0].img.data, "base64");
        var img2 = Buffer.from(records[1].img.data, "base64");
        var images = [img1, img2];


        const formatedImages = images.map(buffer => {
            return `data:image/png;base64,${buffer.toString("base64")}`
        })
        // If I remove ".join(""), then the images won't be displayed, but we will have the img tag in string displayed 




        const image = `data:image/png;base64,${records[0].img.data.toString("base64")}`;
        const coords = records[0].coordinates;
        const address = records[0].address;
        const placeMeaning = records[0].placeMeaning;



        var dataObject = []
        var i = 0;
        for (i; i < records.length; i++) {
            dataObject.push({
                image: `data:image/png;base64,${records[i].img.data.toString("base64")}`,
                coords: records[i].coordinates,
                address: records[i].address,
                placeMeaning: records[i].placeMeaning,
            })
        }


        res.render('userInputs', { userData: dataObject });


      

    })

 

})


// ========================================================================= //


app.get("/images", (req, res) => { // this route allows us to see all the files that we submitted through the "/status/input" route.


    Image.find({}).exec((error, records) => { // the find function in MongoDB is used to find all the records, or records with specific parametes. 
        if (error) {
            res.send(error);
        } else {
            res.send(records);
        }
    })


});


app.get("/showimage", (req, res) => {

    Image.findOne({ "address": "736 Riverside Dr, NY" }, function (error, result) {

        var data = result.img.data;
        var img = Buffer.from(data, "base64");

        res.writeHead(200, {
            "Content-Type": "image/png",
            "Content-Length": img.length,
        });
        res.end(img);

        console.log(img);
    })
})











// ======  CONNECT TO THE DATABASE USING MONGOOSE ====== //

mongoose.connect("mongodb://127.0.0.1:27017/photoUpload", { useNewUrlParser: true, useUnifiedTopology: true },
    () => {
        console.log("connected")
    });

// ====== CREATE A SCHEMA WITH MONGOOSE  ====== //
// == OUR DATA TYPE FOR THE IMAGE IS BUFFER == //


var imageSchema = new mongoose.Schema({
    user: {
        type: String,
        required: true
    },

    address: {
        type: String,
        required: true
    },

    coordinates: {
        type: Array,
        required: true

    },
    placeMeaning: {
        type: String,
        required: true
    },

    img: {
        data: Buffer,
        contentType: String,
    }


});

var Image = new mongoose.model("Image", imageSchema);


const path = require("path");
